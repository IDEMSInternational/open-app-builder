import { Component, computed, effect, OnInit, signal } from "@angular/core";
import { defineAuthorParameterSchema, TemplateBaseComponentWithParams } from "../base";
import type { Swiper, SwiperOptions } from "swiper/types";
import { register } from "swiper/element/bundle";
import { TaskService } from "src/app/shared/services/task/task.service";
import { toObservable, toSignal } from "@angular/core/rxjs-interop";
import { filter, map, switchMap } from "rxjs";
import { DataItemsService } from "../data-items/data-items.service";

const AuthorSchema = defineAuthorParameterSchema((coerce) => ({
  slides_per_view: coerce.custom<SwiperOptions["slidesPerView"]>((value) => {
    if (value === "auto") return "auto";
    const parsed = Number(value);
    return Number.isNaN(parsed) ? "auto" : parsed;
  }, "auto"),
  space_between: coerce.number(10),
  loop: coerce.boolean(false),
  centred_slides: coerce.boolean(true),
  initial_slide_index: coerce.number(0),
  task_group_data: coerce.string(""),
}));

@Component({
  selector: "plh-carousel",
  templateUrl: "./carousel.component.html",
  styleUrls: ["./carousel.component.scss"],
  standalone: false,
})
export class TmplCarouselComponent
  extends TemplateBaseComponentWithParams(AuthorSchema)
  implements OnInit
{
  /** Required in the Swiper config if loop is true */
  public loopAdditionalSlides = computed(() => (this.params().loop ? this.rows().length : null));
  private swiperInstance = signal<Swiper | undefined>(undefined);
  /** track swiper component updates to trigger effect */
  private swiperUpdatedTick = signal(0);
  /** index of highlighted task group (legacy task system) */
  private highlightedTaskGroupIndex = signal<number | null>(null);

  // HACK - render rows either from default child begin_items loop, or generated by data_items loop
  public carouselRows = computed(() => {
    return this.dataItemRows() || this.rows();
  });

  // HACK - if using data_items then render child rows nested within the main data_items row
  private dataItemRows = toSignal(
    toObservable(this.rows).pipe(
      map((rows) => rows.find((r) => r.type === "data_items")),
      filter((row) => row !== undefined),
      switchMap((row) => this.dataItemsService.getItemsObservable(row, this.parent.templateRowMap))
    )
  );

  constructor(
    private taskService: TaskService,
    private dataItemsService: DataItemsService
  ) {
    super();
    /** Slide to initial slide â€“ either authored param or highlighted task group index (legacy task system) */
    effect(() => {
      const swiper = this.swiperInstance();
      this.swiperUpdatedTick();
      const rowsCount = this.rows().length;
      const authoredIndex = this.params().initialSlideIndex;
      const highlightedTaskIndex = this.highlightedTaskGroupIndex();
      if (!swiper || !this.rowSignal() || rowsCount === 0) return;
      const targetIndex = highlightedTaskIndex ?? authoredIndex;
      this.slideToIndex(swiper, targetIndex);
    });
    /** Legacy task system: update the highlighted task group index for centring associated slide (async so effect) */
    effect(() => {
      const taskGroupData = this.params().taskGroupData;
      this.setHighlightedTaskGroupIndex(taskGroupData);
    });
  }

  ngOnInit() {
    if (!customElements.get("swiper-container")) {
      register();
    }
  }

  /** Event emitter called when swiper initialised */
  public handleSwiperInitialised(event: Event) {
    const swiperEvent = event as CustomEvent<Swiper | [Swiper]>;
    const swiper = Array.isArray(swiperEvent.detail) ? swiperEvent.detail[0] : swiperEvent.detail;
    this.swiperInstance.set(swiper);
    this.swiperUpdatedTick.update((v) => v + 1);

    // HACK - Observe slides length change to ensure slider is fully initialised before sliding to initial slide
    swiper.on("slidesLengthChange", () => {
      this.swiperUpdatedTick.update((v) => v + 1);
    });
  }

  private slideToIndex(swiper: Swiper, targetIndex: number) {
    if (this.params().loop) {
      swiper.slideToLoop(targetIndex, 0, false);
    } else {
      swiper.slideTo(targetIndex, 0, false);
    }
  }

  private async setHighlightedTaskGroupIndex(taskGroupDataListName: string) {
    if (!taskGroupDataListName) {
      this.highlightedTaskGroupIndex.set(null);
      return;
    }
    const index = await this.taskService.getHighlightedTaskGroupIndex(taskGroupDataListName);
    this.highlightedTaskGroupIndex.set(index === -1 ? 0 : index);
  }
}
