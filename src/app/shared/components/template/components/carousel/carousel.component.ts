import { Component, computed, effect, OnInit, signal } from "@angular/core";
import { defineAuthorParameterSchema, TemplateBaseComponentWithParams } from "../base";
import type { Swiper, SwiperOptions } from "swiper/types";
import { register } from "swiper/element/bundle";
import { TaskService } from "src/app/shared/services/task/task.service";
import { toObservable, toSignal } from "@angular/core/rxjs-interop";
import { filter, map, switchMap } from "rxjs";
import { DataItemsService } from "../data-items/data-items.service";

const AuthorSchema = defineAuthorParameterSchema((coerce) => ({
  slides_per_view: coerce.custom<SwiperOptions["slidesPerView"]>((value) => {
    if (value === "auto") return "auto";
    const parsed = Number(value);
    return Number.isNaN(parsed) ? "auto" : parsed;
  }, "auto"),
  space_between: coerce.number(10),
  loop: coerce.boolean(false),
  centred_slides: coerce.boolean(true),
  initial_slide_index: coerce.number(0),
  task_group_data: coerce.string(""),
}));

@Component({
  selector: "plh-carousel",
  templateUrl: "./carousel.component.html",
  styleUrls: ["./carousel.component.scss"],
  standalone: false,
})
export class TmplCarouselComponent
  extends TemplateBaseComponentWithParams(AuthorSchema)
  implements OnInit
{
  /** Required in the Swiper config if loop is true */
  public loopAdditionalSlides = computed(() =>
    this.params().loop ? this.rows().length : undefined
  );
  private swiperInstance = signal<Swiper | undefined>(undefined);

  // HACK - render rows either from default child begin_items loop, or generated by data_items loop
  public carouselRows = computed(() => {
    return this.dataItemRows() || this.rows();
  });

  // HACK - if using data_items then render child rows nested within the main data_items row
  private dataItemRows = toSignal(
    toObservable(this.rows).pipe(
      map((rows) => rows.find((r) => r.type === "data_items")),
      filter((row) => row !== undefined),
      switchMap((row) => this.dataItemsService.getItemsObservable(row, this.parent.templateRowMap))
    )
  );

  constructor(
    private taskService: TaskService,
    private dataItemsService: DataItemsService
  ) {
    super();
    effect(() => {
      const swiper = this.swiperInstance();
      const rowsCount = this.rows().length;
      const initialSlideIndex = this.params().initialSlideIndex;
      if (!swiper || !this.rowSignal() || rowsCount === 0) return;
      this.slideToIndex(swiper, initialSlideIndex);

      // if making use of task groups, set initial slide based on highlighted task
      if (this.params().taskGroupData) {
        this.hackSetInitialSlideBasedOnTaskGroup();
      }
    });
  }

  async ngOnInit() {
    if (!customElements.get("swiper-container")) {
      register();
    }
  }

  /** Event emitter called when swiper initialised */
  public handleSwiperInitialised(event: Event) {
    const swiperEvent = event as CustomEvent<Swiper | [Swiper]>;
    const swiper = Array.isArray(swiperEvent.detail) ? swiperEvent.detail[0] : swiperEvent.detail;
    this.swiperInstance.set(swiper);

    // HACK - Observe slides length change to ensure slider is fully initialised before sliding to initial slide
    swiper.on("slidesLengthChange", () => {
      console.log("slidesLengthChange", swiper);
      this.slideToIndex(swiper, this.params().initialSlideIndex);
    });
    this.slideToIndex(swiper, this.params().initialSlideIndex);
  }

  private async slideToIndex(swiper: Swiper, targetIndex: number) {
    if (this.params().loop) {
      swiper.slideToLoop(targetIndex, 0, false);
    } else {
      swiper.slideTo(targetIndex, 0, false);
    }
  }

  /** Workaround for legacy task system - set initial slide after init based on highlighted task */
  private async hackSetInitialSlideBasedOnTaskGroup() {
    const indexOfHighlightedTask = await this.taskService.getHighlightedTaskGroupIndex(
      this.params().taskGroupData
    );
    // if highlightes task is not in list, default to 0 for initial slide
    if (indexOfHighlightedTask === -1) {
      this.params().initialSlideIndex = 0;
    } else {
      this.params().initialSlideIndex = indexOfHighlightedTask;
    }
  }
}
