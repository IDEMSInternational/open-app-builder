import {
  AfterViewInit,
  Component,
  computed,
  ElementRef,
  OnInit,
  signal,
  ViewChild,
} from "@angular/core";
import { toObservable, toSignal } from "@angular/core/rxjs-interop";
import { filter, map, switchMap } from "rxjs";
import { TemplateBaseComponent } from "src/app/shared/components/template/components/base";
import { DataItemsService } from "src/app/shared/components/template/components/data-items/data-items.service";
import { TemplateTranslateService } from "src/app/shared/components/template/services/template-translate.service";
import {
  getIonContentHeight,
  setIonContentScrollTop,
} from "src/app/shared/components/template/utils";
import {
  getBooleanParamFromTemplateRow,
  getStringParamFromTemplateRow,
} from "src/app/shared/utils";

interface IPlhProgressPathParams {
  /** TEMPLATE_PARAMETER: "background_image_asset". Used to set the progress path background */
  backgroundImageAsset: string;
  /**
   * TEMPLATE_PARAMETER: "start_at_bottom". If true, child items will start at bottom of path
   * and component will scroll to the bottom on page load */
  startAtBottom: boolean;
}

@Component({
  selector: "plh-progress-path",
  templateUrl: "./progress-path.component.html",
  styleUrls: ["./progress-path.component.scss"],
})
export class PlhProgressPathComponent
  extends TemplateBaseComponent
  implements OnInit, AfterViewInit
{
  public loading = signal(true);
  public width = `420px`;
  params: Partial<IPlhProgressPathParams> = {};
  @ViewChild("progressPath", { static: false }) progressPath!: ElementRef;

  // HACK - render child rows either from default child begin_items loop, or generated by data_items loop
  public progressRows = computed(() => {
    return this.dataItemRows() || this.rows();
  });

  // HACK - if using data_items then render child rows nested within the main data_items row
  private dataItemRows = toSignal(
    toObservable(this.rows).pipe(
      map((rows) => rows.find((r) => r.type === "data_items")),
      filter((row) => row !== undefined),
      switchMap((row) => this.dataItemsService.getItemsObservable(row, this.parent.templateRowMap)),
      map((items) => (this.params.startAtBottom ? [...items].reverse() : items))
    )
  );

  constructor(
    public templateTranslateService: TemplateTranslateService,
    private dataItemsService: DataItemsService
  ) {
    super();
  }

  ngOnInit() {
    this.getParams();
  }

  ngAfterViewInit() {
    this.scrollToCentre();
    setTimeout(() => {
      this.loading.set(false);
    }, 100);
  }

  // Scroll to centre the starting child step in the viewport
  private scrollToCentre() {
    const element = this.progressPath.nativeElement;

    // Scroll component content horizontally to centre component content
    const scrollLeft = (element.scrollWidth - window.innerWidth) / 2;
    element.scrollTo({
      left: scrollLeft,
    });

    if (this.params.startAtBottom) {
      console.log("scrolling to bottom");
      // Scroll parent ion-content element to the bottom
      const height = getIonContentHeight(this.progressPath);
      setIonContentScrollTop(this.progressPath, height);
    }
  }

  private getParams() {
    this.params.backgroundImageAsset = getStringParamFromTemplateRow(
      this._row,
      "background_image_asset",
      null
    );
    this.params.startAtBottom = getBooleanParamFromTemplateRow(this._row, "start_at_bottom", false);
  }
}
