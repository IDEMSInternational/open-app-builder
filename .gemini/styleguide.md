# Style Guide for Our Angular Monorepo
(generated by Gemini 2.5 pro)
(alt. source could base from https://github.com/google/timesketch/blob/master/.gemini/styleguide.md)

## Introduction

This style guide provides a set of conventions for developing in this Angular monorepo. The goal is to enhance readability, maintainability, and collaboration among developers. By adhering to these guidelines, we can ensure a consistent and high-quality codebase. This guide is a living document and will evolve as our project and best practices change.

This guide assumes Angular v21+ (for signals, built-in control flow, and signal inputs).

This guide promotes the use of modern Angular features, including:
* **Signals**: For reactive state management (`signal`, `computed`, `effect`).
* **Signal Inputs**: For component inputs.
* **Built-in Control Flow**: (`@if`, `@for`, `@switch`) in templates.
* **ESLint and Prettier**: For code linting and formatting.

## Guiding Principles

* **Consistency**: A consistent codebase is easier to read and understand.
* **Readability**: Write code for humans first, computers second.
* **Maintainability**: Well-structured and documented code is easier to maintain and refactor.
* **Efficiency**: Strive for efficient algorithms and data structures, but don't sacrifice readability for minor performance gains.
* **Testability**: Code should be written in a way that is easy to test.

## Component Authoring

### Folder Structure
Use separate files for html, scss, ts and spec.ts files, e.g.

```text
user-profile/
├── user-profile.component.ts
├── user-profile.component.html
├── user-profile.component.scss
├── user-profile.component.spec.ts
```

### Signals for State Management

Signals are the primary tool for state.


* **`signal`**: Use for mutable state.

    ```typescript
    import { signal } from '@angular/core';

    export class MyComponent {
      counter = signal(0);

      increment() {
        this.counter.update(c => c + 1);
      }
    }
    ```

 Follow these priorities for deriving state:

  1. `computed`: First choice for synchronous derivations.

```typescript
import { signal, computed } from '@angular/core';

export class MyComponent {
  price = signal(10);
  quantity = signal(5);
  total = computed(() => this.price() * this.quantity());
}
```

  2. `linkedSignal` (Angular v19+): First choice for state that has a "default" value based on another signal but must remain locally mutable.

```typescript
// ✅ Preferred: highlightedTaskGroupIndex resets/updates when params change
highlightedTaskGroupIndex = linkedSignal({
  source: () => this.params().taskGroupData,
  computation: (data) => this.calculateDefaultIndex(data)
});
```

  3. `effect`: Reserved for side effects and complex state synchronization that cannot be handled by the above.

```typescript
// ✅ Acceptable: Using an effect for an async operation that updates state
effect(() => {
  const data = this.params().taskGroupData;
  
  // Direct, readable async flow
  this.taskService.getHighlightedTaskGroupIndex(data).then(index => {
    this.highlightedTaskGroupIndex.set(index === -1 ? 0 : index);
  });
});
```

**When to Update Signals in Effects**

While the general rule is to avoid updating signals inside effect, this is permissible (and often preferred over complex RxJS chains) in the following scenarios:

Asynchronous Synchronization: When a signal change must trigger an async call (e.g., a service request) whose result updates another signal.

External API Integration: Synchronizing signal state with non-signal-based APIs (e.g., Chart.js, Google Maps, or complex legacy services).

Pragmatic Complexity: If the RxJS alternative (using toObservable and toSignal) requires more than 3-4 operators or significantly obscures the intent of the code, a simple effect with an update is acceptable.   



### Signal Inputs

Use the `input` function for defining component inputs. This creates a signal-based input that is read-only.

```typescript
import { Component, input } from '@angular/core';

@Component({
  selector: 'app-user-profile',
  template: `<p>User: {{ user().name }}</p>`,
})
export class UserProfileComponent {
  user = input.required<{ name: string }>();
}
```

### Built-in Control Flow

Use the new built-in control flow syntax in templates for better type checking and performance.

* **`@if`**: For conditional rendering.

    ```html
    @if (user()) {
      <p>Welcome, {{ user().name }}</p>
    } @else {
      <p>Please log in.</p>
    }
    ```

* **`@for`**: For iterating over collections. Always use `track` to improve performance.

    ```html
    <ul>
      @for (item of items(); track item.id) {
        <li>{{ item.name }}</li>
      } @empty {
        <li>No items found.</li>
      }
    </ul>
    ```

* **`@switch`**: For multi-conditional rendering.

    ```html
    @switch (accessLevel()) {
      @case ('admin') { <p>Admin access</p> }
      @case ('user') { <p>User access</p> }
      @default { <p>Guest access</p> }
    }
    ```

### Component Communication

* **Parent to Child**: Use signal `input`s.
* **Child to Parent**: Use `@Output()` with `EventEmitter`.

## Tooling

### ESLint

ESLint is configured to enforce consistent coding styles and catch potential errors. The configuration is in the `.eslintrc.json` file at the root of the monorepo. All new code must pass ESLint checks without any errors.

### Prettier

Prettier is used for automatic code formatting. It ensures a consistent code style across the entire codebase. Configure your IDE to format on save using Prettier. The Prettier configuration is in the `.prettierrc` file.

## Testing

* Write unit tests for all new components, services, and other logic.
* Aim for high test coverage, but prioritize testing critical and complex logic.
* Tests should be co-located with the files they are testing (e.g., `my-component.component.spec.ts`).

### Testing Signals

When testing components that use signals, you can directly interact with the signals in your tests.

```typescript
import { MyComponent } from './my.component';

describe('MyComponent', () => {
  it('should increment the counter', () => {
    const component = new MyComponent();
    expect(component.counter()).toBe(0);
    component.increment();
    expect(component.counter()).toBe(1);
  });
});
```

## Naming Conventions

* **Files**: Use kebab-case (e.g., `user-profile.component.ts`).
* **Classes**: Use PascalCase (e.g., `UserProfileComponent`).
* **Variables and Functions**: Use camelCase (e.g., `userName`, `getUserData`).
    * **Exception**: snake_case is allowed when defining properties exposed to the template authoring schema.
    ```typescript
    const AuthorSchema = defineAuthorParameterSchema((coerce) => ({
      snake_case_property: coerce.string(),
    }));
    ```
* **Signals**: Treat them as reactive state; naming should reflect the data they hold (e.g., `currentUser`, `products`).
* **`@Output()`**: Name event handlers based on the event they emit (e.g., `@Output() userSaved = new EventEmitter<User>();`).

## Commit Messages
* Use [Conventional Commits](https://www.conventionalcommits.org/)

## Documentation

* Use TSDoc for documenting public APIs in services and components.
* Add comments to explain complex or non-obvious code.
* Keep comments up-to-date with code changes.

By following this style guide, we can create a more cohesive and maintainable codebase that is easier for all developers to work with.