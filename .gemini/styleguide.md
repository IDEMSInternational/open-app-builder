# Style Guide for Our Angular Monorepo
(generated by Gemini 2.5 pro)
(alt. source could base from https://github.com/google/timesketch/blob/master/.gemini/styleguide.md)

## Introduction

This style guide provides a set of conventions for developing in this Angular monorepo. The goal is to enhance readability, maintainability, and collaboration among developers. By adhering to these guidelines, we can ensure a consistent and high-quality codebase. This guide is a living document and will evolve as our project and best practices change.

This guide assumes Angular v18+ (for signals, built-in control flow, and signal inputs).

This guide promotes the use of modern Angular features, including:
* **Signals**: For reactive state management (`signal`, `computed`, `effect`).
* **Signal Inputs**: For component inputs.
* **Built-in Control Flow**: (`@if`, `@for`, `@switch`) in templates.
* **ESLint and Prettier**: For code linting and formatting.

## Guiding Principles

* **Consistency**: A consistent codebase is easier to read and understand.
* **Readability**: Write code for humans first, computers second.
* **Maintainability**: Well-structured and documented code is easier to maintain and refactor.
* **Efficiency**: Strive for efficient algorithms and data structures, but don't sacrifice readability for minor performance gains.
* **Testability**: Code should be written in a way that is easy to test.

## Component Authoring

### Folder Structure
Use separate files for html, scss, ts and spec.ts files, e.g.

```text
user-profile/
├── user-profile.component.ts
├── user-profile.component.html
├── user-profile.component.scss
├── user-profile.component.spec.ts
```

### Signals for State Management

Signals are the preferred way to manage component state.

* **`signal`**: Use for mutable state.

    ```typescript
    import { signal } from '@angular/core';

    export class MyComponent {
      counter = signal(0);

      increment() {
        this.counter.update(c => c + 1);
      }
    }
    ```

* **`computed`**: Use for deriving state from other signals. Computed signals are read-only and memoized.

    ```typescript
    import { signal, computed } from '@angular/core';

    export class MyComponent {
      price = signal(10);
      quantity = signal(5);
      total = computed(() => this.price() * this.quantity());
    }
    ```

* **`effect`**: Use for side effects that should run when a signal's value changes. Use effects sparingly and primarily for rendering, logging, or synchronization with browser APIs. Avoid using effects to update other signals.

    ```typescript
    import { effect, signal } from '@angular/core';

    export class MyComponent {
      name = signal('John Doe');

      constructor() {
        effect(() => {
          console.log(`Name changed to: ${this.name()}`);
        });
      }
    }
    ```

### Signal Inputs

Use the `input` function for defining component inputs. This creates a signal-based input that is read-only.

```typescript
import { Component, input } from '@angular/core';

@Component({
  selector: 'app-user-profile',
  template: `<p>User: {{ user().name }}</p>`,
})
export class UserProfileComponent {
  user = input.required<{ name: string }>();
}
```

### Built-in Control Flow

Use the new built-in control flow syntax in templates for better type checking and performance.

* **`@if`**: For conditional rendering.

    ```html
    @if (user()) {
      <p>Welcome, {{ user().name }}</p>
    } @else {
      <p>Please log in.</p>
    }
    ```

* **`@for`**: For iterating over collections. Always use `track` to improve performance.

    ```html
    <ul>
      @for (item of items(); track item.id) {
        <li>{{ item.name }}</li>
      } @empty {
        <li>No items found.</li>
      }
    </ul>
    ```

* **`@switch`**: For multi-conditional rendering.

    ```html
    @switch (accessLevel()) {
      @case ('admin') { <p>Admin access</p> }
      @case ('user') { <p>User access</p> }
      @default { <p>Guest access</p> }
    }
    ```

### Component Communication

* **Parent to Child**: Use signal `input`s.
* **Child to Parent**: Use `@Output()` with `EventEmitter`.

## Tooling

### ESLint

ESLint is configured to enforce consistent coding styles and catch potential errors. The configuration is in the `.eslintrc.json` file at the root of the monorepo. All new code must pass ESLint checks without any errors.

### Prettier

Prettier is used for automatic code formatting. It ensures a consistent code style across the entire codebase. Configure your IDE to format on save using Prettier. The Prettier configuration is in the `.prettierrc` file.

## Testing

* Write unit tests for all new components, services, and other logic.
* Aim for high test coverage, but prioritize testing critical and complex logic.
* Tests should be co-located with the files they are testing (e.g., `my-component.component.spec.ts`).

### Testing Signals

When testing components that use signals, you can directly interact with the signals in your tests.

```typescript
import { MyComponent } from './my.component';

describe('MyComponent', () => {
  it('should increment the counter', () => {
    const component = new MyComponent();
    expect(component.counter()).toBe(0);
    component.increment();
    expect(component.counter()).toBe(1);
  });
});
```

## Naming Conventions

* **Files**: Use kebab-case (e.g., `user-profile.component.ts`).
* **Classes**: Use PascalCase (e.g., `UserProfileComponent`).
* **Variables and Functions**: Use camelCase (e.g., `userName`, `getUserData`).
* **Signals**: Treat them as reactive state; naming should reflect the data they hold (e.g., `currentUser`, `products`).
* **`@Output()`**: Name event handlers based on the event they emit (e.g., `@Output() userSaved = new EventEmitter<User>();`).

## Commit Messages
* Use [Conventional Commits](https://www.conventionalcommits.org/)

## Documentation

* Use TSDoc for documenting public APIs in services and components.
* Add comments to explain complex or non-obvious code.
* Keep comments up-to-date with code changes.

By following this style guide, we can create a more cohesive and maintainable codebase that is easier for all developers to work with.